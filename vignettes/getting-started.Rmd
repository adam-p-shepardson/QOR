---
title: "Getting Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r hidden_setup_start, include=FALSE, eval=TRUE}
## Hidden code chunk for setting up my graphics
# Pathing
here::i_am(".here")
local_path <- here::here() 

# create the data-raw/Downloads and data-raw/Extracted folders if they don't exist
if (!dir.exists(paste0(here::here(), "data-raw/Downloads"))) {
  dir.create(paste0(here::here(), "data-raw/Downloads"), recursive = TRUE)
}
if (!dir.exists(paste0(here::here(), "data-raw/Extracted"))) {
  dir.create(paste0(here::here(), "data-raw/Extracted"), recursive = TRUE)
}

# Increase timeout for large files
options(timeout = 1000)

# Define URLs (example: North Carolina 2022 data)
zip_codes <- "https://www.dropbox.com/scl/fi/sq0mudsvm1g7c9ljbiye1/ZIP_2022.zip?rlkey=v9gqxsx0b1dli7lnoi95qwlyv&st=p7lprz1m&dl=1"
state_shape <- "https://www.dropbox.com/scl/fi/a8bn3ht1d67xd412zixf5/North_Carolina_State_Boundary.zip?rlkey=2j0at3vvts5i62trqvm4itpa5&st=0soqpq4j&dl=1"
district_shapes <- "https://www.dropbox.com/scl/fi/eh557z55pg9051dq4mves/SCHOOL_SY2022.zip?rlkey=ds8a7pocgj7evgsmvhsn9dyow&st=tecyt8yc&dl=1"

# Download shapefiles
download.file(url = zip_codes, destfile = paste0(local_path, "data-raw/Downloads/zip_codes_2022.zip"), mode = "wb", method = "auto")
unzip(zipfile = paste0(local_path, "data-raw/Downloads/zip_codes_2022.zip"), exdir = paste0(local_path, "data-raw/Extracted"))
download.file(url = state_shape, destfile = paste0(local_path, "data-raw/Downloads/state_shape.zip"), mode = "wb", method = "auto")
unzip(zipfile = paste0(local_path, "data-raw/Downloads/state_shape.zip"), exdir = paste0(local_path, "data-raw/Extracted"))
download.file(url = district_shapes, destfile = paste0(local_path, "data-raw/Downloads/district_shapes_2022.zip"), mode = "wb", method = "auto")
unzip(zipfile = paste0(local_path, "data-raw/Downloads/district_shapes_2022.zip"), exdir = paste0(local_path, "data-raw/Extracted")) 
```

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

The following brief tutorial demonstrates how to use the three main functions in the QOR package: `query()`, `overlay()`, and `recover()`. This example uses an anonymized sample of voter addresses as well as school district, state, and zip code shapefiles from North Carolina.

# Load Package and Data

```{r setup, eval=TRUE, message=FALSE, warning=FALSE}
# You would need your local path below to run the setup examples:
local_path <- here::here()  # Change this to your local path

# Packages for example
library(tidyverse)
library(sf)
library(QOR)

# Load example voter addresses
example <- haven::read_dta(system.file("example_data", "sample_2022_addresses.dta", package = "QOR"))

# Load shapefiles (see Data Setup vignette for download instructions)
state_shape <- read_sf(dsn = paste0(local_path, "data-raw/Extracted/North_Carolina_State_Boundary")) %>%
  dplyr::summarize(geometry = st_union(geometry)) %>%
  st_make_valid()
zip_shape <- sf::read_sf(dsn = paste0(local_path, "data-raw/Extracted/ZIP_2022")) %>%
  st_make_valid()
district_shape <- sf::read_sf(dsn = paste0(local_path, "data-raw/Extracted/SCHOOL_SY2022")) %>%
  st_make_valid()
```

# Query: Geocode Addresses

The first step is to geocode unit addresses using the `query()` function. This function takes a data frame of addresses and returns two data frames: one with successfully geocoded points and another with addresses that could not be geocoded.

```{r query, eval=TRUE, message=FALSE, warning=FALSE}
test_query <- query(
  units = example,
  unit_id = "statevoterid",
  street = "street",
  city = "city",
  state = "state",
  state_shape = state_shape,
  units_per_batch = 4000, # note: up to 10,000 for Census geocoder, but connection issues can arise with large batches
  method = "census",
  sleep_time = 2,
  year = 2022,
  unit_zip = "postalcode",
  max_tries = 15
)

matched <- test_query[[1]]    # Successfully geocoded (use for Overlay)
unmatched <- test_query[[2]]  # Failed to geocode (use for Recover)
```

We can demonstrate that the geocoding worked by plotting the matched points against the state boundary and district shapes:

```{r query_plot, eval=TRUE, message=FALSE, warning=FALSE}
# Packages for plotting
library(ggplot2)
library(ggthemes)

# Filter down to just NC districts
district_shape_temp <- district_shape %>% filter(STATEFP == 37) # NC is FIPS 37

# Plot geocoded points
plot <- ggplot() +
    geom_sf(data = state_shape, alpha = 0) +
    geom_sf(data = matched, pch = "*", size = 3, alpha = 0.2, aes(color = "Geocoded Voters")) +
    geom_sf(data = district_shape_temp, alpha = 0.1, color = "darkmagenta", size = 0.5, aes(fill = "School Districts")) +
    scale_color_manual(values = "black") +
    scale_fill_manual(values = "white") +
    labs(title = paste0(as.character(2022), " Small Sample of Geocoded Voters in North Carolina"),
         caption = "Notes: \nWhere district files are sourced from the U.S. Census Bureau \nand voter information is sourced from the State of North Carolina. \nGraph reflects successful geocoding matches from sample.",
         fill = "", color = "") +
    ggthemes::theme_map() +
    theme(legend.position = "bottom", legend.direction = "horizontal", plot.caption = element_text(hjust = 0),
          panel.background = element_rect(fill = "white", color = "white"), plot.background = element_rect(fill = "white", color = "white"))

rm(district_shape_temp)

print(plot) # display map

```


# Overlay: Match Voters to Districts

The second step is to overlay the geocoded points onto the district shapefiles using the `overlay()` function. This function assigns each geocoded point to a polygon (school district) based on spatial location.

```{r overlay}
test_overlay <- overlay(
  points = matched,
  polygons = district_shape,
  point_id = "statevoterid",
  polygon_id = "GEOID",
  used_NCES = TRUE,
  FIPS_code = "37",
  FIPS_col = "STATEFP"
)
```

# Recover: Assign Unmatched Voters

The final step is to recover the unmatched units using the `recover()` function. This function uses zip code information and spatial distances between zip code and polygon centers to assign unmatched units to polygons.

```{r recover}
test_recover <- recover(
  units = unmatched,
  polygons = district_shape,
  zipcodes = zip_shape,
  unit_id = "statevoterid",
  unit_zip = "postalcode",
  polygon_id = "GEOID",
  zip_id = "ZCTA5CE20",
  state_shape = state_shape,
  used_NCES = TRUE,
  FIPS_code = "37",
  FIPS_col = "STATEFP"
)

matched_byzip <- test_recover[[1]]    # Successfully matched to a district by zipcode
no_zip <- test_query[[2]]  # Failed to map unit zip code to a Census-recognized zip code for that year

```


# Why Does This Work?

QOR leverages the fact that voters, school districts, and zip codes are all spatial entities convertable to the same coordinate reference system (CRS). The visualization below shows, conceptually, the three different layers. 

Geocoded voter points from `query()` can be overlaid onto school district polygons used in `overlay()` to identify which voters live in which districts. For unmatched voters, QOR uses zip code polygons in `recover()` as an intermediary spatial unit to help assign voters to districts based on proximity.

```{r why_it_works, eval=TRUE, message=FALSE, warning=FALSE, echo=FALSE}

# Package for a 3D plot
library(rgl)

# Zip changes
zip_shape <- zip_shape %>%
  rename(., postalcode = ZCTA5CE20)

# Generate random dots to represent possible voter locations
set.seed(1)
voters <- st_sample(state_shape, size = 1000, type = "random")
voters <- st_sf(geometry = voters)

# Equalize coordinate systems
NC_map <- st_transform(state_shape, crs = st_crs(district_shape))
voters <- st_transform(voters, crs = st_crs(district_shape))
zip_shape <- st_transform(zip_shape, crs = st_crs(district_shape))

# Filter down to just NC districts and zipcodes
district_shape_temp <- district_shape %>% filter(STATEFP == 37) # NC is FIPS 37. See: https://www2.census.gov/geo/docs/reference/codes2020/national_state2020.txt
zip_shape <- zip_shape %>%
  st_filter(., NC_map)

## 3D Plot showing layers
# store Z offsets
z_offsets <- c(0, 2, 4, 6)

# Add a default 3rd dimension to the needed shapefiles
zipcode_shape3d <- st_zm(zip_shape, drop = FALSE, what = "Z")
zipcode_shape3d <- st_sf(geometry = zipcode_shape3d)

districts_shape3d <- st_zm(district_shape_temp, drop = FALSE, what = "Z")
districts_shape3d <- st_sf(geometry = districts_shape3d)

voters3d <- st_zm(voters, drop = FALSE, what = "Z")
voters3d <- st_sf(geometry = voters3d)

# store 3D shapefiles in list
shapefiles <- list(zipcode_shape3d, districts_shape3d, voters3d)

# put colors in a vector
colors <- c("darkgreen", "darkred", "navyblue")

# Put labels for shapefile layers in a vector
labels <- c("Zip Code Layer", "School District Layer", "Voter Layer")

create_3d_plot <- function(shapefiles, z_offsets, colors, labels, angle_x = 45, angle_y = 30, zoom = .7) {
  
  open3d()  # Open a new 3D device using rgl package
  
  # Loop through shapefiles and plot each layer
  for (i in seq_along(shapefiles)) {
    shapefile <- shapefiles[[i]]
    z_offset <- z_offsets[i]
    color <- colors[i]
    
    # Get geometry type for the shapefile
    geom_type <- unique(st_geometry_type(shapefile))
    
    # Plotting the polygons
    if (any(geom_type %in% c("POLYGON", "MULTIPOLYGON"))) {
      
      # Sample only about 70% of the polygons (save RAM)
      sample_size <- floor(0.7 * nrow(shapefile))
      sample_index <- sample(seq_len(nrow(shapefile)), sample_size)
      
      for (j in seq_len(nrow(shapefile))) {
        if (!j %in% sample_index) {
          next 
        } # Skip non-sampled polygons
        polygon <- st_geometry(shapefile[j, ])
        coords <- st_coordinates(polygon)
        coords[, "Z"] <- z_offset  # Uniform Z-offset

        # Divide total num of points by some arbitrary value to build less technically demanding figures (reduce points for large polygons to improve performance)
        decimation <- max(1, nrow(coords) %/% 500)
        idx <- seq(1, nrow(coords), by = decimation)
        coords <- coords[idx, ]
        
        # Plot each ring separately
        unique_rings <- unique(coords[, "L1"])
        for (ring in unique_rings) {
          ring_coords <- coords[coords[, "L1"] == ring, ]
          lines3d(ring_coords[, 1], ring_coords[, 2], ring_coords[, 3], col = color, lwd = 1)
        }
      }
    }
    
    # Plotting Points
    if (any(geom_type == "POINT")) {
      coords <- st_coordinates(shapefile)
      # Only keep 500 random points (became too much)
      n_keep <- min(500, nrow(coords))
      keep_idx <- sample(seq_len(nrow(coords)), n_keep)
      coords <- coords[keep_idx, ]
      coords[, "Z"] <- coords[, "Z"] + z_offset  # Adjust existing 0 Z-values
      points3d(coords[, 1], coords[, 2], coords[, 3], col = color, alpha = 0.6, size = 2)
    }
  }
  
  # Add a 2D box on the base layer (Z = 0)
  bbox <- st_bbox(do.call(c, lapply(shapefiles, st_geometry)))
  box_coords <- rbind(
    c(bbox["xmin"], bbox["ymin"], 0),
    c(bbox["xmax"], bbox["ymin"], 0),
    c(bbox["xmax"], bbox["ymax"], 0),
    c(bbox["xmin"], bbox["ymax"], 0),
    c(bbox["xmin"], bbox["ymin"], 0)
  )
  
  # Adjust view
  view3d(theta = angle_x, phi = angle_y, zoom = zoom)
  
  # Add title
  text3d(x = mean(c(bbox["xmin"], bbox["xmax"]) - 1), 
         y = bbox["ymax"] + 1.5,  # Adjust position above plot
         z = min(z_offsets), 
         texts = "Three Step QOR Process", 
         cex = 2.5, 
         adj = c(0.5, 0.5),
         font = 2)
  
  # Add legend
  add_legend <- function(labels, colors, x = -1, y = 2, z = 2, spacing = 2) {
    n <- length(labels)
    for (i in seq_along(labels)) {
      points3d(x, y - i * spacing, z, col = colors[i], size = 10)
      text3d(x + 0.2, y - i * spacing, z, labels[i], adj = c(0, 0.5), cex = 1.5)
    }
  }
  add_legend(labels, colors, x = bbox["xmax"] - 7.9, y = bbox["ymax"] - 7.4, z = 2, spacing = 1)
  
  # Ensure no axis labels
  title3d(xlab = "", ylab = "", zlab = "")
  
}

create_3d_plot(shapefiles, z_offsets, colors, labels)

# Set the size of the 3D plot window
rgl::par3d(windowRect = c(0, 0, 1280, 720))  # 1280x720 resolution

# Capture the 3D plot for HTML output
rglwidget()
```

Note: The 3D plot above is interactive! Feel free to rotate and zoom to explore the layers. We only load about 70% of districts and zipcodes at random to reduce browser memory burden. Simulated "voter" points are also randomly distributed without regard to population densities.

```{r hidden_setup_end, include=FALSE, eval=TRUE}
# Hidden code chunk for deleting downloaded files after use
# Zipped files
files_to_delete <- c(paste0(local_path, "data-raw/Downloads/zip_codes_2022.zip"), 
paste0(local_path, "data-raw/Downloads/state_shape.zip"), paste0(local_path, "data-raw/Downloads/district_shapes_2022.zip"))
file.remove(files_to_delete)

# Extracted files
names <- c("ZIP_2022", "North_Carolina_State_Boundary", "SCHOOL_SY2022")
for (name in names) {
  to_delete <- list.files(paste0(local_path, "data-raw/Extracted/", name), full.names = TRUE)
  file.remove(to_delete)
}
```