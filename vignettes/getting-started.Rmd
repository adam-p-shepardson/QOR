---
title: "Getting Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

The following brief tutorial demonstrates how to use the three main functions in the QOR package: `query()`, `overlay()`, and `recover()`. This example uses a small sample of North Carolina voter addresses and North Carolina school district, state, and zip code shapefiles.

# Load Package and Data

```{r setup}
# Load QOR
library(QOR)

# Load example voter addresses
example <- haven::read_dta(system.file("example_data", "sample_2022_addresses.dta", package = "QOR"))

# Load shapefiles (see Data Setup vignette for download instructions)
state_shape <- sf::read_sf(dsn = "data-raw/Extracted/North_Carolina_State_Boundary") %>%
  dplyr::summarize(geometry = sf::st_union(geometry))
zip_shape <- sf::read_sf(dsn = "data-raw/Extracted/ZIP_2022")
district_shape <- read_sf(dsn = "data-raw/Extracted/SCHOOL_SY2022")
```

# Query: Geocode Addresses
The first step is to geocode unit addresses using the `query()` function. This function takes a data frame of addresses and returns two data frames: one with successfully geocoded points and another with addresses that could not be geocoded.

```{r query, eval=TRUE, message=FALSE, warning=FALSE}
test_query <- query(
  units = example,
  unit_id = "statevoterid",
  street = "street",
  city = "city",
  state = "state",
  state_shape = state_shape,
  units_per_batch = 4000,
  method = "census",
  sleep_time = 2,
  year = 2022,
  zip_id = "postalcode"
)

matched <- test_query[[1]]    # Successfully geocoded (use for Overlay)
unmatched <- test_query[[2]]  # Failed to geocode (use for Recover)
```

We can demonstrate that the geocoding worked by plotting the matched points against the state boundary and district shapes:
```{r query_plot, eval=TRUE, message=FALSE, warning=FALSE}






```


# Overlay: Match Voters to Districts
The second step is to overlay the geocoded points onto the district shapefiles using the `overlay()` function. This function assigns each geocoded point to a polygon (school district) based on spatial location.

```{r overlay}
test_overlay <- overlay(
  points = matched,
  polygons = district_shape,
  point_id = "statevoterid",
  polygon_id = "GEOID",
  used_NCES = TRUE,
  state_FIPS = "37"
)
```

# Recover: Assign Unmatched Voters
The final step is to recover the unmatched units using the `recover()` function. This function uses zip code information and spatial distances between zip code and polygon centers to assign unmatched units to polygons.

```{r recover}
test_recover <- recover(
  units = unmatched,
  polygons = district_shape,
  zipcodes = zip_shape,
  unit_id = "statevoterid",
  unit_zip = "postalcode",
  polygon_id = "GEOID",
  zip_id = "ZCTA5CE20",
  state_shape = state_shape,
  used_NCES = TRUE,
  state_FIPS = "37"
)
```


# Why Does This Work?
QOR leverages the fact that voters, school districts, and zip codes are all spatial entities convertable to the same coordinate reference system (CRS). 

The visualization below shows, conceptually, how geocoded voter points (from `query()`) can be overlaid onto school district polygons (from `overlay()`) to identify which voters live in which districts. For unmatched voters, QOR uses zip code polygons (from `recover()`) as an intermediary spatial unit to help assign voters to districts based on proximity.

```{r why_it_works, eval=TRUE, message=FALSE, warning=FALSE}



```